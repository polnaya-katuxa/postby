package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/interfaces.ReactionRepository -o ./internal/mocks/reaction_repository_mock_test.go -n ReactionRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/keo20u511/ppo/backend/internal/logic/models"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ReactionRepositoryMock implements interfaces.ReactionRepository
type ReactionRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID) (err error)
	inspectFuncCreate   func(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mReactionRepositoryMockCreate

	funcDelete          func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error)
	inspectFuncDelete   func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mReactionRepositoryMockDelete

	funcGetAll          func(ctx context.Context, u1 uuid.UUID) (rpa1 []*models.Reaction, err error)
	inspectFuncGetAll   func(ctx context.Context, u1 uuid.UUID)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mReactionRepositoryMockGetAll

	funcReacted          func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (b1 bool, err error)
	inspectFuncReacted   func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)
	afterReactedCounter  uint64
	beforeReactedCounter uint64
	ReactedMock          mReactionRepositoryMockReacted
}

// NewReactionRepositoryMock returns a mock for interfaces.ReactionRepository
func NewReactionRepositoryMock(t minimock.Tester) *ReactionRepositoryMock {
	m := &ReactionRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mReactionRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*ReactionRepositoryMockCreateParams{}

	m.DeleteMock = mReactionRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ReactionRepositoryMockDeleteParams{}

	m.GetAllMock = mReactionRepositoryMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*ReactionRepositoryMockGetAllParams{}

	m.ReactedMock = mReactionRepositoryMockReacted{mock: m}
	m.ReactedMock.callArgs = []*ReactionRepositoryMockReactedParams{}

	return m
}

type mReactionRepositoryMockCreate struct {
	mock               *ReactionRepositoryMock
	defaultExpectation *ReactionRepositoryMockCreateExpectation
	expectations       []*ReactionRepositoryMockCreateExpectation

	callArgs []*ReactionRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// ReactionRepositoryMockCreateExpectation specifies expectation struct of the ReactionRepository.Create
type ReactionRepositoryMockCreateExpectation struct {
	mock    *ReactionRepositoryMock
	params  *ReactionRepositoryMockCreateParams
	results *ReactionRepositoryMockCreateResults
	Counter uint64
}

// ReactionRepositoryMockCreateParams contains parameters of the ReactionRepository.Create
type ReactionRepositoryMockCreateParams struct {
	ctx context.Context
	rp1 *models.Reaction
	u1  uuid.UUID
}

// ReactionRepositoryMockCreateResults contains results of the ReactionRepository.Create
type ReactionRepositoryMockCreateResults struct {
	err error
}

// Expect sets up expected params for ReactionRepository.Create
func (mmCreate *mReactionRepositoryMockCreate) Expect(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID) *mReactionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ReactionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ReactionRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &ReactionRepositoryMockCreateParams{ctx, rp1, u1}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ReactionRepository.Create
func (mmCreate *mReactionRepositoryMockCreate) Inspect(f func(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID)) *mReactionRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ReactionRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ReactionRepository.Create
func (mmCreate *mReactionRepositoryMockCreate) Return(err error) *ReactionRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ReactionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ReactionRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ReactionRepositoryMockCreateResults{err}
	return mmCreate.mock
}

// Set uses given function f to mock the ReactionRepository.Create method
func (mmCreate *mReactionRepositoryMockCreate) Set(f func(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID) (err error)) *ReactionRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ReactionRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ReactionRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the ReactionRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mReactionRepositoryMockCreate) When(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID) *ReactionRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ReactionRepositoryMock.Create mock is already set by Set")
	}

	expectation := &ReactionRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &ReactionRepositoryMockCreateParams{ctx, rp1, u1},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ReactionRepository.Create return parameters for the expectation previously defined by the When method
func (e *ReactionRepositoryMockCreateExpectation) Then(err error) *ReactionRepositoryMock {
	e.results = &ReactionRepositoryMockCreateResults{err}
	return e.mock
}

// Create implements interfaces.ReactionRepository
func (mmCreate *ReactionRepositoryMock) Create(ctx context.Context, rp1 *models.Reaction, u1 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, rp1, u1)
	}

	mm_params := &ReactionRepositoryMockCreateParams{ctx, rp1, u1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := ReactionRepositoryMockCreateParams{ctx, rp1, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ReactionRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ReactionRepositoryMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, rp1, u1)
	}
	mmCreate.t.Fatalf("Unexpected call to ReactionRepositoryMock.Create. %v %v %v", ctx, rp1, u1)
	return
}

// CreateAfterCounter returns a count of finished ReactionRepositoryMock.Create invocations
func (mmCreate *ReactionRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ReactionRepositoryMock.Create invocations
func (mmCreate *ReactionRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ReactionRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mReactionRepositoryMockCreate) Calls() []*ReactionRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ReactionRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ReactionRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *ReactionRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReactionRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ReactionRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to ReactionRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to ReactionRepositoryMock.Create")
	}
}

type mReactionRepositoryMockDelete struct {
	mock               *ReactionRepositoryMock
	defaultExpectation *ReactionRepositoryMockDeleteExpectation
	expectations       []*ReactionRepositoryMockDeleteExpectation

	callArgs []*ReactionRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// ReactionRepositoryMockDeleteExpectation specifies expectation struct of the ReactionRepository.Delete
type ReactionRepositoryMockDeleteExpectation struct {
	mock    *ReactionRepositoryMock
	params  *ReactionRepositoryMockDeleteParams
	results *ReactionRepositoryMockDeleteResults
	Counter uint64
}

// ReactionRepositoryMockDeleteParams contains parameters of the ReactionRepository.Delete
type ReactionRepositoryMockDeleteParams struct {
	ctx context.Context
	u1  uuid.UUID
	u2  uuid.UUID
}

// ReactionRepositoryMockDeleteResults contains results of the ReactionRepository.Delete
type ReactionRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for ReactionRepository.Delete
func (mmDelete *mReactionRepositoryMockDelete) Expect(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *mReactionRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ReactionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ReactionRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &ReactionRepositoryMockDeleteParams{ctx, u1, u2}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the ReactionRepository.Delete
func (mmDelete *mReactionRepositoryMockDelete) Inspect(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)) *mReactionRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ReactionRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by ReactionRepository.Delete
func (mmDelete *mReactionRepositoryMockDelete) Return(err error) *ReactionRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ReactionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ReactionRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ReactionRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the ReactionRepository.Delete method
func (mmDelete *mReactionRepositoryMockDelete) Set(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error)) *ReactionRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the ReactionRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the ReactionRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the ReactionRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mReactionRepositoryMockDelete) When(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *ReactionRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ReactionRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &ReactionRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ReactionRepositoryMockDeleteParams{ctx, u1, u2},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up ReactionRepository.Delete return parameters for the expectation previously defined by the When method
func (e *ReactionRepositoryMockDeleteExpectation) Then(err error) *ReactionRepositoryMock {
	e.results = &ReactionRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements interfaces.ReactionRepository
func (mmDelete *ReactionRepositoryMock) Delete(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, u1, u2)
	}

	mm_params := &ReactionRepositoryMockDeleteParams{ctx, u1, u2}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := ReactionRepositoryMockDeleteParams{ctx, u1, u2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ReactionRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ReactionRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, u1, u2)
	}
	mmDelete.t.Fatalf("Unexpected call to ReactionRepositoryMock.Delete. %v %v %v", ctx, u1, u2)
	return
}

// DeleteAfterCounter returns a count of finished ReactionRepositoryMock.Delete invocations
func (mmDelete *ReactionRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ReactionRepositoryMock.Delete invocations
func (mmDelete *ReactionRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ReactionRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mReactionRepositoryMockDelete) Calls() []*ReactionRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ReactionRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ReactionRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ReactionRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReactionRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ReactionRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to ReactionRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to ReactionRepositoryMock.Delete")
	}
}

type mReactionRepositoryMockGetAll struct {
	mock               *ReactionRepositoryMock
	defaultExpectation *ReactionRepositoryMockGetAllExpectation
	expectations       []*ReactionRepositoryMockGetAllExpectation

	callArgs []*ReactionRepositoryMockGetAllParams
	mutex    sync.RWMutex
}

// ReactionRepositoryMockGetAllExpectation specifies expectation struct of the ReactionRepository.GetAll
type ReactionRepositoryMockGetAllExpectation struct {
	mock    *ReactionRepositoryMock
	params  *ReactionRepositoryMockGetAllParams
	results *ReactionRepositoryMockGetAllResults
	Counter uint64
}

// ReactionRepositoryMockGetAllParams contains parameters of the ReactionRepository.GetAll
type ReactionRepositoryMockGetAllParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// ReactionRepositoryMockGetAllResults contains results of the ReactionRepository.GetAll
type ReactionRepositoryMockGetAllResults struct {
	rpa1 []*models.Reaction
	err  error
}

// Expect sets up expected params for ReactionRepository.GetAll
func (mmGetAll *mReactionRepositoryMockGetAll) Expect(ctx context.Context, u1 uuid.UUID) *mReactionRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ReactionRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &ReactionRepositoryMockGetAllExpectation{}
	}

	mmGetAll.defaultExpectation.params = &ReactionRepositoryMockGetAllParams{ctx, u1}
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the ReactionRepository.GetAll
func (mmGetAll *mReactionRepositoryMockGetAll) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mReactionRepositoryMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for ReactionRepositoryMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by ReactionRepository.GetAll
func (mmGetAll *mReactionRepositoryMockGetAll) Return(rpa1 []*models.Reaction, err error) *ReactionRepositoryMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ReactionRepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &ReactionRepositoryMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &ReactionRepositoryMockGetAllResults{rpa1, err}
	return mmGetAll.mock
}

// Set uses given function f to mock the ReactionRepository.GetAll method
func (mmGetAll *mReactionRepositoryMockGetAll) Set(f func(ctx context.Context, u1 uuid.UUID) (rpa1 []*models.Reaction, err error)) *ReactionRepositoryMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the ReactionRepository.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the ReactionRepository.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	return mmGetAll.mock
}

// When sets expectation for the ReactionRepository.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mReactionRepositoryMockGetAll) When(ctx context.Context, u1 uuid.UUID) *ReactionRepositoryMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ReactionRepositoryMock.GetAll mock is already set by Set")
	}

	expectation := &ReactionRepositoryMockGetAllExpectation{
		mock:   mmGetAll.mock,
		params: &ReactionRepositoryMockGetAllParams{ctx, u1},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up ReactionRepository.GetAll return parameters for the expectation previously defined by the When method
func (e *ReactionRepositoryMockGetAllExpectation) Then(rpa1 []*models.Reaction, err error) *ReactionRepositoryMock {
	e.results = &ReactionRepositoryMockGetAllResults{rpa1, err}
	return e.mock
}

// GetAll implements interfaces.ReactionRepository
func (mmGetAll *ReactionRepositoryMock) GetAll(ctx context.Context, u1 uuid.UUID) (rpa1 []*models.Reaction, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx, u1)
	}

	mm_params := &ReactionRepositoryMockGetAllParams{ctx, u1}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rpa1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_got := ReactionRepositoryMockGetAllParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("ReactionRepositoryMock.GetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the ReactionRepositoryMock.GetAll")
		}
		return (*mm_results).rpa1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx, u1)
	}
	mmGetAll.t.Fatalf("Unexpected call to ReactionRepositoryMock.GetAll. %v %v", ctx, u1)
	return
}

// GetAllAfterCounter returns a count of finished ReactionRepositoryMock.GetAll invocations
func (mmGetAll *ReactionRepositoryMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of ReactionRepositoryMock.GetAll invocations
func (mmGetAll *ReactionRepositoryMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to ReactionRepositoryMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mReactionRepositoryMockGetAll) Calls() []*ReactionRepositoryMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*ReactionRepositoryMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *ReactionRepositoryMock) MinimockGetAllDone() bool {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllInspect logs each unmet expectation
func (m *ReactionRepositoryMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReactionRepositoryMock.GetAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ReactionRepositoryMock.GetAll")
		} else {
			m.t.Errorf("Expected call to ReactionRepositoryMock.GetAll with params: %#v", *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && mm_atomic.LoadUint64(&m.afterGetAllCounter) < 1 {
		m.t.Error("Expected call to ReactionRepositoryMock.GetAll")
	}
}

type mReactionRepositoryMockReacted struct {
	mock               *ReactionRepositoryMock
	defaultExpectation *ReactionRepositoryMockReactedExpectation
	expectations       []*ReactionRepositoryMockReactedExpectation

	callArgs []*ReactionRepositoryMockReactedParams
	mutex    sync.RWMutex
}

// ReactionRepositoryMockReactedExpectation specifies expectation struct of the ReactionRepository.Reacted
type ReactionRepositoryMockReactedExpectation struct {
	mock    *ReactionRepositoryMock
	params  *ReactionRepositoryMockReactedParams
	results *ReactionRepositoryMockReactedResults
	Counter uint64
}

// ReactionRepositoryMockReactedParams contains parameters of the ReactionRepository.Reacted
type ReactionRepositoryMockReactedParams struct {
	ctx context.Context
	u1  uuid.UUID
	u2  uuid.UUID
}

// ReactionRepositoryMockReactedResults contains results of the ReactionRepository.Reacted
type ReactionRepositoryMockReactedResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for ReactionRepository.Reacted
func (mmReacted *mReactionRepositoryMockReacted) Expect(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *mReactionRepositoryMockReacted {
	if mmReacted.mock.funcReacted != nil {
		mmReacted.mock.t.Fatalf("ReactionRepositoryMock.Reacted mock is already set by Set")
	}

	if mmReacted.defaultExpectation == nil {
		mmReacted.defaultExpectation = &ReactionRepositoryMockReactedExpectation{}
	}

	mmReacted.defaultExpectation.params = &ReactionRepositoryMockReactedParams{ctx, u1, u2}
	for _, e := range mmReacted.expectations {
		if minimock.Equal(e.params, mmReacted.defaultExpectation.params) {
			mmReacted.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReacted.defaultExpectation.params)
		}
	}

	return mmReacted
}

// Inspect accepts an inspector function that has same arguments as the ReactionRepository.Reacted
func (mmReacted *mReactionRepositoryMockReacted) Inspect(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)) *mReactionRepositoryMockReacted {
	if mmReacted.mock.inspectFuncReacted != nil {
		mmReacted.mock.t.Fatalf("Inspect function is already set for ReactionRepositoryMock.Reacted")
	}

	mmReacted.mock.inspectFuncReacted = f

	return mmReacted
}

// Return sets up results that will be returned by ReactionRepository.Reacted
func (mmReacted *mReactionRepositoryMockReacted) Return(b1 bool, err error) *ReactionRepositoryMock {
	if mmReacted.mock.funcReacted != nil {
		mmReacted.mock.t.Fatalf("ReactionRepositoryMock.Reacted mock is already set by Set")
	}

	if mmReacted.defaultExpectation == nil {
		mmReacted.defaultExpectation = &ReactionRepositoryMockReactedExpectation{mock: mmReacted.mock}
	}
	mmReacted.defaultExpectation.results = &ReactionRepositoryMockReactedResults{b1, err}
	return mmReacted.mock
}

// Set uses given function f to mock the ReactionRepository.Reacted method
func (mmReacted *mReactionRepositoryMockReacted) Set(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (b1 bool, err error)) *ReactionRepositoryMock {
	if mmReacted.defaultExpectation != nil {
		mmReacted.mock.t.Fatalf("Default expectation is already set for the ReactionRepository.Reacted method")
	}

	if len(mmReacted.expectations) > 0 {
		mmReacted.mock.t.Fatalf("Some expectations are already set for the ReactionRepository.Reacted method")
	}

	mmReacted.mock.funcReacted = f
	return mmReacted.mock
}

// When sets expectation for the ReactionRepository.Reacted which will trigger the result defined by the following
// Then helper
func (mmReacted *mReactionRepositoryMockReacted) When(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *ReactionRepositoryMockReactedExpectation {
	if mmReacted.mock.funcReacted != nil {
		mmReacted.mock.t.Fatalf("ReactionRepositoryMock.Reacted mock is already set by Set")
	}

	expectation := &ReactionRepositoryMockReactedExpectation{
		mock:   mmReacted.mock,
		params: &ReactionRepositoryMockReactedParams{ctx, u1, u2},
	}
	mmReacted.expectations = append(mmReacted.expectations, expectation)
	return expectation
}

// Then sets up ReactionRepository.Reacted return parameters for the expectation previously defined by the When method
func (e *ReactionRepositoryMockReactedExpectation) Then(b1 bool, err error) *ReactionRepositoryMock {
	e.results = &ReactionRepositoryMockReactedResults{b1, err}
	return e.mock
}

// Reacted implements interfaces.ReactionRepository
func (mmReacted *ReactionRepositoryMock) Reacted(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmReacted.beforeReactedCounter, 1)
	defer mm_atomic.AddUint64(&mmReacted.afterReactedCounter, 1)

	if mmReacted.inspectFuncReacted != nil {
		mmReacted.inspectFuncReacted(ctx, u1, u2)
	}

	mm_params := &ReactionRepositoryMockReactedParams{ctx, u1, u2}

	// Record call args
	mmReacted.ReactedMock.mutex.Lock()
	mmReacted.ReactedMock.callArgs = append(mmReacted.ReactedMock.callArgs, mm_params)
	mmReacted.ReactedMock.mutex.Unlock()

	for _, e := range mmReacted.ReactedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmReacted.ReactedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReacted.ReactedMock.defaultExpectation.Counter, 1)
		mm_want := mmReacted.ReactedMock.defaultExpectation.params
		mm_got := ReactionRepositoryMockReactedParams{ctx, u1, u2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReacted.t.Errorf("ReactionRepositoryMock.Reacted got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReacted.ReactedMock.defaultExpectation.results
		if mm_results == nil {
			mmReacted.t.Fatal("No results are set for the ReactionRepositoryMock.Reacted")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmReacted.funcReacted != nil {
		return mmReacted.funcReacted(ctx, u1, u2)
	}
	mmReacted.t.Fatalf("Unexpected call to ReactionRepositoryMock.Reacted. %v %v %v", ctx, u1, u2)
	return
}

// ReactedAfterCounter returns a count of finished ReactionRepositoryMock.Reacted invocations
func (mmReacted *ReactionRepositoryMock) ReactedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReacted.afterReactedCounter)
}

// ReactedBeforeCounter returns a count of ReactionRepositoryMock.Reacted invocations
func (mmReacted *ReactionRepositoryMock) ReactedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReacted.beforeReactedCounter)
}

// Calls returns a list of arguments used in each call to ReactionRepositoryMock.Reacted.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReacted *mReactionRepositoryMockReacted) Calls() []*ReactionRepositoryMockReactedParams {
	mmReacted.mutex.RLock()

	argCopy := make([]*ReactionRepositoryMockReactedParams, len(mmReacted.callArgs))
	copy(argCopy, mmReacted.callArgs)

	mmReacted.mutex.RUnlock()

	return argCopy
}

// MinimockReactedDone returns true if the count of the Reacted invocations corresponds
// the number of defined expectations
func (m *ReactionRepositoryMock) MinimockReactedDone() bool {
	for _, e := range m.ReactedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReactedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReactedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReacted != nil && mm_atomic.LoadUint64(&m.afterReactedCounter) < 1 {
		return false
	}
	return true
}

// MinimockReactedInspect logs each unmet expectation
func (m *ReactionRepositoryMock) MinimockReactedInspect() {
	for _, e := range m.ReactedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReactionRepositoryMock.Reacted with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReactedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReactedCounter) < 1 {
		if m.ReactedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ReactionRepositoryMock.Reacted")
		} else {
			m.t.Errorf("Expected call to ReactionRepositoryMock.Reacted with params: %#v", *m.ReactedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReacted != nil && mm_atomic.LoadUint64(&m.afterReactedCounter) < 1 {
		m.t.Error("Expected call to ReactionRepositoryMock.Reacted")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReactionRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetAllInspect()

		m.MinimockReactedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReactionRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReactionRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockReactedDone()
}
